import 'zone.js/dist/zone-node';

import { ngExpressEngine } from '@nguniversal/express-engine';
import * as express from 'express';
import * as session from 'express-session';
import { Express } from 'express';
import { join } from 'path';

import { AppServerModule } from './src/main.server';
import { APP_BASE_HREF } from '@angular/common';
import { existsSync } from 'fs';

const helmet = require('helmet');

// The Express app is exported so that it can be used by serverless Functions.
export function app(): Express {
  const server: Express = express();

  // Security headers.
  server.use(helmet());

  // Content Seucurity Policy (CSP).
  server.use(
    helmet.contentSecurityPolicy({
      directives: {
        blockAllMixedContent: [], // Prevent loading any assets using HTTP when the page is loaded using HTTPS.
        childSrc: [
          "'self'", // Default policy for valid sources for web workers and nested browsing contexts loaded using elements such as "<frame>" and "<iframe>": allow all content coming from origin (without subdomains).
        ],
        connectSrc: [
          "'self'", // Default policy for restricting the URLs which can be loaded using script interfaces: allow all content coming from origin (without subdomains).
          'https://demo-api.vercel.app/users', // Given API.
        ],
        defaultSrc: [
          "'none'", // Default policy for fallback for the other CSP fetch directives [Link of these: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/default-src]: disallows everything.
        ],
        fontSrc: [
          'https://fonts.gstatic.com', // Default policy for specifiying valid sources for fonts loaded using "@font-face": allow all content coming from origin (without subdomains).
        ],
        formAction: ["'self'"], // Default policy for restricting the URLs which can be used as the target of a form submissions from a given context: allow all content coming from origin (without subdomains).
        frameAncestors: ["'self'"], // Default policy for specyfing valid parents that may embed a page using "<frame>", "<iframe>", "<object>", "<embed>", or "<applet>". This directive doesn't use "default-src" as fallback, thus by default it allows anything. This is basically clickjacking protection.
        frameSrc: [
          "'self'", // Default policy for specyfing valid sources for nested browsing contexts loading using elements such as "<frame>" and "<iframe>": allow all content coming from origin (without subdomains).
        ],
        imgSrc: ["'self'"],
        manifestSrc: ["'self'"], // Default policy for specyfing which manifest can be applied to the resource: allow all content coming from origin (without subdomains).
        scriptSrc: [
          "'self'", // Default policy for valid sources for JavaScript: allow all content coming from origin (without subdomains).
        ],
        styleSrc: [
          "'self'", // Default policy for valid sources for stylesheets: allow all content coming from origin (without subdomains).
          "https: 'unsafe-inline'", // Unsecure, but required in order to render styles generated by Angular compiler, which on SSR are generated as inline styles.
        ],
        upgradeInsecureRequests: [], // Block loading of active/passive content over insecure FTP/HTTP by "upgrading" the connection to secure SFTP/HTTPS.
      },
    })
  );

  const sessionSettings: any = session({
    cookie: {
      maxAge: 3600000, // In milliseconds, keep the session for maximum 1 hour and later expire it. Cookie by default (in the csrf package) has the same expiration date.
      secure: true, // Enforce cookies has to be transmitted only through HTTPS. It prevents cookie from being transmitted through insecure HTTP.
      sameSite: true, // Mitigate risk of cross-origin information leakage. Robust refence against CSRF, mitigate XSSI too.
      signed: true, // Sign a cookie to prevent from cookie forging.
    },
    name: 'SESSION_ID', // Change default name of session cookie which reveals application's internal technology. For Express apps this is "connect.sid".
    resave: false, // Disable forcing session to be saved back to the sessions store, even if the session was never modified during the request. Enabling it could potentially create race conditions where client makes 2 parallels requests to the server.
    saveUninitialized: true, // Save uninitialized session to the store.
    secret: 'MY_SECRET', // Shouldn't be like that on production.
  });
  server.use(sessionSettings);

  server.use(helmet.referrerPolicy({ policy: 'same-origin' })); // Send Referer header only for pages on the same origin.

  // Preload HTTP Strict Transport Security (HSTS).
  server.use(
    helmet.hsts({
      includeSubDomains: true, // Must be enabled, so "preload" will work.
      maxAge: 31536000, // In seconds, one year.
      preload: true,
    })
  );

  const distFolder = join(process.cwd(), 'functions/dist/app-fedex/browser');
  const indexHtml = existsSync(join(distFolder, 'index.original.html'))
    ? 'index.original.html'
    : 'index';

  // Our Universal express-engine (found @ https://github.com/angular/universal/tree/master/modules/express-engine)
  server.engine(
    'html',
    ngExpressEngine({
      bootstrap: AppServerModule,
    })
  );

  server.set('view engine', 'html');
  server.set('views', distFolder);

  // Example Express Rest API endpoints
  // server.get('/api/**', (req, res) => { });
  // Serve static files from /browser
  server.get(
    '*.*',
    express.static(distFolder, {
      maxAge: '1y',
    })
  );

  // All regular routes use the Universal engine
  server.get('*', (req, res) => {
    res.render(indexHtml, {
      req,
      providers: [{ provide: APP_BASE_HREF, useValue: req.baseUrl }],
    });
  });

  return server;
}

function run(): void {
  const port = process.env.PORT || 4000;

  // Start up the Node server
  const server = app();
  server.listen(port, () => {
    console.log(`Node Express server listening on http://localhost:${port}`);
  });
}

// Webpack will replace 'require' with '__webpack_require__'
// '__non_webpack_require__' is a proxy to Node 'require'
// The below code is to ensure that the server is run only when not requiring the bundle.
declare const __non_webpack_require__: NodeRequire;
const mainModule = __non_webpack_require__.main;
const moduleFilename = (mainModule && mainModule.filename) || '';
if (moduleFilename === __filename || moduleFilename.includes('iisnode')) {
  run();
}

export * from './src/main.server';
